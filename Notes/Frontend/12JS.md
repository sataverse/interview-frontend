## js
- 동적인 웹페이지를 만들기 위한 프로그래밍 언어. 웹페이지를 조작하고, c-s간 소통에 관한 모든 일 관여.
- JS로 작성한 프로그램을 script라고 부르며 script는 웹페이지의 html에 작성이 가능. 웹페이지를 불러올 때 scipt 자동 실행.
- node.js는 서버에서 실행하는 JS, 파일을 읽거나 쓰고 네트워크 요청을 수행.
- 브라우저에서 메모리나 CPU의 조작을 허용하지 않음
- 동적 프로토타입 기반 객체 지향 script 언어이며 함수도 일급 객체임.
- 동적 타입 언어: 변수 타입이 없어 프로그램 실행 도중 변수에 저장되는 데이터 타입이 동적으로 바뀜.
- 싱글 스레드: 한 번에 하나의 태스크만 처리. stack 위에 함수를 올려 실행하고 끝나면 제거.
- non-blocking 언어: 이벤트 루프와 콜백 큐가 있어서 비동기 처리 가능.

## ECMAScript
- ecma(국제표준기구)라는 기관이 만든 스크립트 언어로 ECMA-262 표준을 따름, 자바스크립트를 개발한 Netscapre가 향상된 표준화를 위해 기술규결을 Ecma에게 제출

## JS 엔진
- 자바스크립트 코드를 해석하고 실행시켜주는 프로그램 혹은 인터프리터.
- 자바스크립트 자체는 인터프리터 언어지만 웹 브라우저 대부분에는 JIT 컴파일러가 내장되어 있어 실행 속도가 빠름.
- 메모리를 관리하는 Heap과 태스크를 관리하는 Stack영역으로 구분.
- 엔진이 script 파싱 -> script를 기계어로 컴파일 -> 기계어 실행(삐름)

## 콜 스택과 힙
- 자바스크립트 엔진이 자바스크립트를 실행할 때 원시 타입 및 참조 타입을 저장하는 메모리 구조
- 콜 스택: 원시타입 값과 함수 호출의 실행 컨텍스트 저장하는 자료구조
- 힙: 객체, 배열, 함수와 같이 크기가 동적으로 변할 수 있는 참조타입 저장.

## 실행 컨텍스트
- 코드의 실행환경에 대한 여러가지 정보를 담고 있는 개념
- 자바스크립트의 코드는 글로벌 스코프에서 실행하는 글로벌 코드, 함수 스코프에서 실행하는 함수 코드, eval()로 실행되는 코드로 이루어짐.
- 엔진이 스크립트 파일을 실행하기 전에 글로벌 실행 컨텍스트가 생성되고(Global Execution Context) 함수를 호출할 때마다 함수실행 컨텍스트 생성.
- 전체 코드 실행이 끝나면 GEC는 가비지 컬렉터에 의해 제거
- 구성요소
    - Lexical Enviroment
        - Enviroment Record: 변수 및 함수 등의 식별자 정보
        - outer 참조: 외부 Lexical Environment 참조하는 포인터
    - Variable Environment: LE와 동일한 성격을 띠지만 var로 선언된 변수만 저장
    - this 바인딩: 실행 컨텍스트가 생성될 때마다 this 객체에 어떻게 바인딩 되는지 나타낸 것

## 스코프
- 자바스크립트 엔진이 참조의 대상이 되는 식별자를 검색할 때 사용하는 규칙의 집합. 이름이 공유되는 공간
- 렉시컬 스코프 : 프로그래머가 코드를 짤 때, 변수 및 함수/블록을 어디에 작성하혔는가에 따라 정해지는 스코프. 어디에 선언하였는지에 따라 결정.
- 스코프 체인: 현재 스코프에서 식별자를 검색할 때 상위 스코프를 연쇄적으로 찾아나가는 방식.

## 호이스팅
- 함수의 선언과 초기화가 동시에 이루어지면 자바스크립트 인터프리터가 변수의 선언을 스코프의 맨 위로 이동시키는 동작.

## 클로저
- 함수가 속한 렉시컬 스코프를 기억하여 함수가 렉시컬 스코프 밖에서 실행될 때도 그 스코프에 접근할 수 있게 하는 기능.

## this 바인딩
- Execution Context가 생성될 때마다 this의 바인딩이 일어남.
- new를 사용했을 때 해당 객체로 바인딩
- call, apply, bind와 같이 명시적 바인딩을 사용했을 때 인자로 전달된 객체에 바인딩.
- 객체의 메소드로 호출할 경우 해당 객체에 바인딩
- 브라우저라면 window객체에 바인딩

## 프로토타입
- 자바스크립트의 모든 객체는 자신의 원형이 되는 객체를 가지며 이를 프로토타입이라고 함.
- 보이지 않는 속성인 [[Prototype]]이 자신의 프로토타입 객체를 참조
- __proto__ 라는 속성으로 참조할 수 있으나 비표준/모든 브라우저 동작x

## 객체
- 자바스크립트의 워시 자료형을 제회한 모든 자료형은 객체 자료형 따라서 배열과 함수는 객체임
- 자바스크립트의 배열은 객체 자료형에 몇가지 기능을 추가해 다른언어의 배열처럼 동작하는 특수한 객체 -> 다양한 프로퍼티와 메서드 존재
- 함수 역시 값으로 취급되기 때문에 함수 표현식이 가능하고 다른 함수에 인자 전달로 가능
- 객체 자료형은 값이 동적으로 늘어나거나 줄기 때문에 일정한 크기의 공간에 저장 불가 : 참조 이용(실제 값을 저장하는 것이 아닌 저장한 곳의 주소 저장)


## 이벤트 전파
- 이벤트 버블링: 하위 엘리먼트에 이벤트 발생시 그 엘리먼트부터 시작해 상위 요소까지 이벤트가 전달. (기본 동작)
- 이벤트 캡쳐링: 하위 엘리먼트에 이벤트 핸들러가 있을 때 상위 엘리먼트부터 이벤트가 발생하기 시작해서 하위 엘리먼트까지 이벤트가 전달.
```javascript
    document.querySelector('ul').addEventListener('click', () => console.log('ul 클릭'), { capture: true });
```
- 이벤트 위임: 하위 엘리먼트들이 여러개 있을 때 하위 엘리먼트들에게 이벤트 핸들러를 달지 않고 상위 엘리먼트에게 이벤트 핸들러를 달아 하위 엘리먼트 제어
- e.stopPropagation(): 이벤트가 상위 엘리먼트에게 전달되지 않게 막아줌
    - e.preventDefault(): html에서 a태그나 submit 태그의 고유 동작을 중단

## 이벤트 루프
- 자바스크립트는 단일 스레드 기반 언어로 JS엔진이 단일 콜 스택을 가짐. 동기적으로 처리 된다는 뜻.
- 비동기 요청은 자바스크립트를 실행하는 환경인 브라우저 또는 Node.js가 담당.
- 자바스크립트 엔진과 실행 환경을 상호 연동시켜주는 장치가 이벤트 루프.
- 콜 스택이 다 비워지면 콜백 큐에 존재하는 함수를 하나씩 콜 스택으로 옮김.
- 이벤트 루프는 2개의 큐를 감시하고 있다가 콜 스택이 비게 되면, 콜백함수를 꺼내와서 실행. 마이크로태스큐의 콜백함수를 전부 실행하고 태스크 큐의 콜백함수를 실행.
    - 콜백함수를 어디에 넣을까?
    - 태스크 큐: setTimeout(), setInterval(), UI렌더링
    - 마이크로태스크큐: Promise, MutationObserver
- Web API는 부라우저에서 제공하는 API로 DOM, Ajax, Timeout 등이 있고 콜스택에서 실행된 비동기 함수는 Web API를 호출하고 Web API는 콜백 함수를 태스크 큐에 넣음.

## 네이티브 객체 vs 호스트 객체
- 네이티브 : Object, Function, Date, Math
- 호스트 : 자바스트립트를 실행하는 환경에 종속된 객체로 그 환경에서만 찾을 수 있음. window, document, loaction, XMLHttpRequest, querySelectorAll

## Strict Mode
- 기존에 무시되던 에러를 발생시키며 함수스코프에 적용 가능 "use strict"
- var 생략 불가, 일반 변수 삭제 불가, 함수의 매개변수 이름 중복 불가, arguments 객체 원본 인자 저장, 8진수 사용불가

## == vs ===
- 참조 타입 비교는 동일하게 작동
- 문자열은 원시타입이자만 객체로도 만들 수 있어서 두개의 동작이 다름
- 엄격한 동등 비교 연산자는 타입변환이 일어나지 않으며 타입이 일치애햐함

## null vs undefined vs NaN
- null: 아무런 값도 나타내지 않는 특수한 값(null로 초기화 해주어야 함)
- undefined: 선언은 되었지만 값이 할당 되지 않음(초기화 안함)
- NaN: 숫자가 아니다, 표현 불가능한 수치형 결과 1/0

## Ajax
- Asynchronous Javascript And XML의 약자로 비동기적으로 JS를 사용해 데이터를 받아와 동적으로 DOM을 갱신하는 웹 개발 기법.
- XMLHttpRequest()와 fetch()

## window vs document
- window
    - window객체는 브라우저 탭에 존재하는 자바스크립트 전역 최상위 객체. 전역으로 선언되어 있어 window객체를 참조하지 않고도 프로터티 이름으로 바로 접근 가능
    - window.addeventlistener
- document
    - DOM에 대한 정보 저장
    - document.querySelector('.class') / document.querySelectorAll('.class')
    - .setAttribute(name, value)
    - .createElement('h1')
    - .appendChild(element)

## 얕은 복사 vs 깊은 복사
- 참조값은 여러 자료형으로 구성되는 메로리에 저장된 객체. 변수에 객체를 저장하면 독립적인 메모리 공간에 값을 저장하고 변수에 저장된 메모리 공간의 참조를 .저장
- 얕은 복사: 객체의 참조 값 복사
- 깊은 복사: 객체의 실제 값 복사

https://velog.io/@suuhyeony/JS-JavaScript%EB%9E%80-%EB%B0%B0%EA%B2%BD-%ED%8A%B9%EC%A7%95-%EC%97%AD%ED%95%A0