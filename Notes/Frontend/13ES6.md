## ES6
### 기본 매개변수

### 화살표 함수
- this키워드의 값은 함수가 정의되는 시점이 아닌 실행되는 시점에 결정. this가 함수 스코프에 바인딩 되지 않고 렉시컬 스코프를 가짐.
- 생성자로 사용불가
- prototype프로퍼티 갖고 있지 않음.

### 클래스
- 프로토타입 기반의 객체지향 패턴을 쉽게 만든 장치

### 객체 리터럴
- 트레일링 콤마 
- 단축 속성명(a:a -> a), 단축 메소드명(f : function(){} -> f(){})
- 계산된 속성 이름([‘ab’ + ‘c’]: 3) / ([name]: ‘a’)

### 템플릿 문자열(멀티라인)
- 백틱 사용, ${}문자열 치환

### 구조분해 할당(비구조화 할당)
- 객체 안의 필드, 배열의 원소를 변수에 쉽게 대입. 
- 없는 원소의 경우 undefined 할당, = 연산자로 초기화, : 연산자로 다른 변수 명

### ...
- 나머지 연산자 : 배열의 일부 부분 배열을 다른 변수에 할당하고자 할때 사용
- 스프레드 연산자 : 여러 개의 변수가 들어갈 자리에 한 배열의 원소들을 분포할때 사용.

### var vs let vs const
- var: 함수 스코프를 가짐. 함수 스코프 최상단으로 호이스팅 되고 선언과 동시에 undefined로 초기화. 글로벌 스코프에서 선언되면 글로벌 객체에 바인딩. window. 으로 접근가능. 재선언 가능
- let: 재할당이 가능한 블록 스코프 변수. let으로 선언한 변수는 블록스코프 최상단으로 호이스팅 되지만 정의되기 전에 참조하면 에러발생. 선언은 블록 내에서 한 번만 가능.
- const: 재할달 불가능한 블록 스코프 변수. 정의되기 전에 참조하면 에러발생. 선언은 초기화를 수반해야함. 재할당이 불가능하지 불변값은 아님.(배열, 객체)
#### 함수수준 스코프
모든 변수 선언이 함수 수준에서 이루어짐. 코드블록{}는 새로운 스코프 생성x.

### 이터레이터
- forEach : return break 불가
- for of : for in과 달리 순회 순서가 항상 같음, for in은 원소의 키에 해당하는 문자열이 바인딩되고, for of은 원소의 실제값이 바인딩. break continue 지원. 순회 가능한 객체만 사용가능(이터러블 프로토콜을 구현한)
- 이터레이터 : 객체가 특정 조건을 만족하는 next() 메소드를 가짐. 이번 원소값과 순회가 끝났는지의 불린값.
- 이터러블 프로토콜 : 이터러블 프로토콜은 프로그래머에게 임의의 객체에 대해 해당 객체를 어떻게 순회할지를 명시하고, 동일할 문법으로 여러 객체를 순회할 수 있는 수단을 제공한다. Array Map Set은 이터러블 프로토콜을 구현.

### 모듈
- import, export

### Map, Set
- 유용한 자료구조

### Promise
- resolve 호출시 비동기 작업이 완료 된 경우의 핸들러인 then, reject호출시 catch
- 들여쓰기 깊이가 늘어나지 않음, 깔끔한 코드
#### fetch
정보를 인자로 받아 네트워크 요청을 실행하고 그 요청에 연결된 프로미스를 리턴

## ES7
- arr.includes(원소, 시작점)
- n ** m

## ES8
### async/await 패턴
- 함수 앞에 async 키워드를 달면 내부에서 await을 사용하여 Promise 객체의 완료를 기다릴 수 있음
- async함수가 반환하는 값은 암시적으로 프로미스로 감싸짐.
### 함수 트래일링 콤마
### Object
- Object.entries()
- Object.values()

## ES9
- 객체 나머지 연산자
- finally

## ES10
- catch의 에러인자 생략 가능
- Array의 flat(), flatMap()

## ES11
- BigInt
- 옵셔널 채이닝
- ??연산자(null 병합 연산자)









